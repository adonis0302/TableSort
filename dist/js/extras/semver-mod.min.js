/*! Modified semver.js for node.js (v4.3.3, 3/27/2015) */
/*
 semver-mod.js by R.Garrison (@Mottie)
 semver.js by @isaacs: https://github.com/isaacs/node-semver
 ( all modifications have been labeled )
 */
// ***** MODIFIED LINE BELOW *****
!function(){function a(a,b){if(a instanceof d)return a;if("string"!=typeof a)return null;if(a.length>U)return null;var c=b?W[la]:W[ia];if(!c.test(a))return null;try{return new d(a,b)}catch(e){return null}}function b(b,c){var d=a(b,c);return d?d.version:null}function c(b,c){var d=a(b.trim().replace(/^[=v]+/,""),c);return d?d.version:null}function d(a,b){if(a instanceof d){if(a.loose===b)return a;a=a.version}else if("string"!=typeof a)throw new TypeError("Invalid Version: "+a);if(a.length>U)throw new TypeError("version is longer than "+U+" characters");if(!(this instanceof d))return new d(a,b);R("SemVer",a,b),this.loose=b;var c=a.trim().match(b?W[la]:W[ia]);if(!c)throw new TypeError("Invalid Version: "+a);if(this.raw=a,
// these are actually numbers
this.major=+c[1],this.minor=+c[2],this.patch=+c[3],this.major>V||this.major<0)throw new TypeError("Invalid major version");if(this.minor>V||this.minor<0)throw new TypeError("Invalid minor version");if(this.patch>V||this.patch<0)throw new TypeError("Invalid patch version");
// numberify any prerelease numeric ids
c[4]?this.prerelease=c[4].split(".").map(function(a){if(/^[0-9]+$/.test(a)){var b=+a;if(b>=0&&V>b)return b}return a}):this.prerelease=[],this.build=c[5]?c[5].split("."):[],this.format()}function e(a,b,c,e){"string"==typeof c&&(e=c,c=void 0);try{return new d(a,c).inc(b,e).version}catch(f){return null}}function f(b,c){if(s(b,c))return null;var d=a(b),e=a(c);if(d.prerelease.length||e.prerelease.length){for(var f in d)if(("major"===f||"minor"===f||"patch"===f)&&d[f]!==e[f])return"pre"+f;return"prerelease"}for(var f in d)if(("major"===f||"minor"===f||"patch"===f)&&d[f]!==e[f])return f}function g(a,b){var c=La.test(a),d=La.test(b);return c&&d&&(a=+a,b=+b),c&&!d?-1:d&&!c?1:b>a?-1:a>b?1:0}function h(a,b){return g(b,a)}function i(a,b){return new d(a,b).major}function j(a,b){return new d(a,b).minor}function k(a,b){return new d(a,b).patch}function l(a,b,c){return new d(a,c).compare(b)}function m(a,b){return l(a,b,!0)}function n(a,b,c){return l(b,a,c)}function o(a,b){return a.sort(function(a,c){return T.compare(a,c,b)})}function p(a,b){return a.sort(function(a,c){return T.rcompare(a,c,b)})}function q(a,b,c){return l(a,b,c)>0}function r(a,b,c){return l(a,b,c)<0}function s(a,b,c){return 0===l(a,b,c)}function t(a,b,c){return 0!==l(a,b,c)}function u(a,b,c){return l(a,b,c)>=0}function v(a,b,c){return l(a,b,c)<=0}function w(a,b,c,d){var e;switch(b){case"===":"object"==typeof a&&(a=a.version),"object"==typeof c&&(c=c.version),e=a===c;break;case"!==":"object"==typeof a&&(a=a.version),"object"==typeof c&&(c=c.version),e=a!==c;break;case"":case"=":case"==":e=s(a,c,d);break;case"!=":e=t(a,c,d);break;case">":e=q(a,c,d);break;case">=":e=u(a,c,d);break;case"<":e=r(a,c,d);break;case"<=":e=v(a,c,d);break;default:throw new TypeError("Invalid operator: "+b)}return e}function x(a,b){if(a instanceof x){if(a.loose===b)return a;a=a.value}return this instanceof x?(R("comparator",a,b),this.loose=b,this.parse(a),this.semver===Ma?this.value="":this.value=this.operator+this.semver.version,void R("comp",this)):new x(a,b)}function y(a,b){if(a instanceof y&&a.loose===b)return a;if(!(this instanceof y))return new y(a,b);if(this.loose=b,
// First, split based on boolean or ||
this.raw=a,this.set=a.split(/\s*\|\|\s*/).map(function(a){return this.parseRange(a.trim())},this).filter(function(a){
// throw out any that are not relevant for whatever reason
return a.length}),!this.set.length)throw new TypeError("Invalid SemVer Range: "+a);this.format()}function z(a,b){return new y(a,b).set.map(function(a){return a.map(function(a){return a.value}).join(" ").trim().split(" ")})}
// comprised of xranges, tildes, stars, and gtlt's at this point.
// already replaced the hyphen ranges
// turn into a set of JUST comparators.
function A(a,b){return R("comp",a),a=E(a,b),R("caret",a),a=C(a,b),R("tildes",a),a=G(a,b),R("xrange",a),a=I(a,b),R("stars",a),a}function B(a){return!a||"x"===a.toLowerCase()||"*"===a}
// ~, ~> --> * (any, kinda silly)
// ~2, ~2.x, ~2.x.x, ~>2, ~>2.x ~>2.x.x --> >=2.0.0 <3.0.0
// ~2.0, ~2.0.x, ~>2.0, ~>2.0.x --> >=2.0.0 <2.1.0
// ~1.2, ~1.2.x, ~>1.2, ~>1.2.x --> >=1.2.0 <1.3.0
// ~1.2.3, ~>1.2.3 --> >=1.2.3 <1.3.0
// ~1.2.0, ~>1.2.0 --> >=1.2.0 <1.3.0
function C(a,b){return a.trim().split(/\s+/).map(function(a){return D(a,b)}).join(" ")}function D(a,b){var c=b?W[xa]:W[wa];return a.replace(c,function(b,c,d,e,f){R("tilde",a,b,c,d,e,f);var g;
// ~1.2 == >=1.2.0- <1.3.0-
// ~1.2.3 == >=1.2.3 <1.3.0
return B(c)?g="":B(d)?g=">="+c+".0.0 <"+(+c+1)+".0.0":B(e)?g=">="+c+"."+d+".0 <"+c+"."+(+d+1)+".0":f?(R("replaceTilde pr",f),"-"!==f.charAt(0)&&(f="-"+f),g=">="+c+"."+d+"."+e+f+" <"+c+"."+(+d+1)+".0"):g=">="+c+"."+d+"."+e+" <"+c+"."+(+d+1)+".0",R("tilde return",g),g})}
// ^ --> * (any, kinda silly)
// ^2, ^2.x, ^2.x.x --> >=2.0.0 <3.0.0
// ^2.0, ^2.0.x --> >=2.0.0 <3.0.0
// ^1.2, ^1.2.x --> >=1.2.0 <2.0.0
// ^1.2.3 --> >=1.2.3 <2.0.0
// ^1.2.0 --> >=1.2.0 <2.0.0
function E(a,b){return a.trim().split(/\s+/).map(function(a){return F(a,b)}).join(" ")}function F(a,b){R("caret",a,b);var c=b?W[Ca]:W[Ba];return a.replace(c,function(b,c,d,e,f){R("caret",a,b,c,d,e,f);var g;return B(c)?g="":B(d)?g=">="+c+".0.0 <"+(+c+1)+".0.0":B(e)?g="0"===c?">="+c+"."+d+".0 <"+c+"."+(+d+1)+".0":">="+c+"."+d+".0 <"+(+c+1)+".0.0":f?(R("replaceCaret pr",f),"-"!==f.charAt(0)&&(f="-"+f),g="0"===c?"0"===d?">="+c+"."+d+"."+e+f+" <"+c+"."+d+"."+(+e+1):">="+c+"."+d+"."+e+f+" <"+c+"."+(+d+1)+".0":">="+c+"."+d+"."+e+f+" <"+(+c+1)+".0.0"):(R("no pr"),g="0"===c?"0"===d?">="+c+"."+d+"."+e+" <"+c+"."+d+"."+(+e+1):">="+c+"."+d+"."+e+" <"+c+"."+(+d+1)+".0":">="+c+"."+d+"."+e+" <"+(+c+1)+".0.0"),R("caret return",g),g})}function G(a,b){return R("replaceXRanges",a,b),a.split(/\s+/).map(function(a){return H(a,b)}).join(" ")}function H(a,b){a=a.trim();var c=b?W[sa]:W[ra];return a.replace(c,function(b,c,d,e,f,g){R("xRange",a,b,c,d,e,f,g);var h=B(d),i=h||B(e),j=i||B(f),k=j;
// nothing is allowed
// replace X with 0
// >1 => >=2.0.0
// >1.2 => >=1.3.0
// >1.2.3 => >= 1.2.4
// <=0.7.x is actually <0.8.0, since any 0.7.x should
// pass.  Similarly, <=7.x is actually <8.0.0, etc.
return"="===c&&k&&(c=""),h?b=">"===c||"<"===c?"<0.0.0":"*":c&&k?(i&&(e=0),j&&(f=0),">"===c?(c=">=",i?(d=+d+1,e=0,f=0):j&&(e=+e+1,f=0)):"<="===c&&(c="<",i?d=+d+1:e=+e+1),b=c+d+"."+e+"."+f):i?b=">="+d+".0.0 <"+(+d+1)+".0.0":j&&(b=">="+d+"."+e+".0 <"+d+"."+(+e+1)+".0"),R("xRange return",b),b})}
// Because * is AND-ed with everything else in the comparator,
// and '' means "any version", just remove the *s entirely.
function I(a,b){
// Looseness is ignored here.  star is always as loose as it gets!
return R("replaceStars",a,b),a.trim().replace(W[Ja],"")}
// This function is passed to string.replace(re[HYPHENRANGE])
// M, m, patch, prerelease, build
// 1.2 - 3.4.5 => >=1.2.0 <=3.4.5
// 1.2.3 - 3.4 => >=1.2.0 <3.5.0 Any 3.4.x will do
// 1.2 - 3.4 => >=1.2.0 <3.5.0
function J(a,b,c,d,e,f,g,h,i,j,k,l,m){return b=B(c)?"":B(d)?">="+c+".0.0":B(e)?">="+c+"."+d+".0":">="+b,h=B(i)?"":B(j)?"<"+(+i+1)+".0.0":B(k)?"<"+i+"."+(+j+1)+".0":l?"<="+i+"."+j+"."+k+"-"+l:"<="+h,(b+" "+h).trim()}function K(a,b){for(var c=0;c<a.length;c++)if(!a[c].test(b))return!1;if(b.prerelease.length){
// Find the set of versions that are allowed to have prereleases
// For example, ^1.2.3-pr.1 desugars to >=1.2.3-pr.1 <2.0.0
// That should allow `1.2.3-pr.2` to pass.
// However, `1.2.4-alpha.notready` should NOT be allowed,
// even though it's within the range set by the comparators.
for(var c=0;c<a.length;c++){if(R(a[c].semver),a[c].semver===Ma)return!0;if(a[c].semver.prerelease.length>0){var d=a[c].semver;if(d.major===b.major&&d.minor===b.minor&&d.patch===b.patch)return!0}}
// Version has a -pre, but it's not one of the ones we like.
return!1}return!0}function L(a,b,c){try{b=new y(b,c)}catch(d){return!1}return b.test(a)}function M(a,b,c){return a.filter(function(a){return L(a,b,c)}).sort(function(a,b){return n(a,b,c)})[0]||null}function N(a,b){try{
// Return '*' instead of '' so that truthiness works.
// This will throw if it's invalid anyway
return new y(a,b).range||"*"}catch(c){return null}}function O(a,b,c){return Q(a,b,"<",c)}function P(a,b,c){return Q(a,b,">",c)}function Q(a,b,c,e){a=new d(a,e),b=new y(b,e);var f,g,h,i,j;switch(c){case">":f=q,g=v,h=r,i=">",j=">=";break;case"<":f=r,g=u,h=q,i="<",j="<=";break;default:throw new TypeError('Must provide a hilo val of "<" or ">"')}
// If it satisifes the range it is not outside
if(L(a,b,e))return!1;
// From now on, variable terms are as if we're in "gtr" mode.
// but note that everything is flipped for the "ltr" function.
for(var k=0;k<b.set.length;++k){var l=b.set[k],m=null,n=null;
// If the edge version comparator has a operator then our version
// isn't outside it
if(l.forEach(function(a){m=m||a,n=n||a,f(a.semver,m.semver,e)?m=a:h(a.semver,n.semver,e)&&(n=a)}),m.operator===i||m.operator===j)return!1;
// If the lowest version comparator has an operator and our version
// is less than it then it isn't higher than the range
if((!n.operator||n.operator===i)&&g(a,n.semver))return!1;if(n.operator===j&&h(a,n.semver))return!1}return!0}
// ***** MODIFIED LINE BELOW *****
var R,S={exports:{}},T=S.exports=d;/* nomin */
R="object"==typeof process&&process.env&&process.env.NODE_DEBUG&&/\bsemver\b/i.test(process.env.NODE_DEBUG)?function(){/* nomin */
var a=Array.prototype.slice.call(arguments,0);/* nomin */
a.unshift("SEMVER"),/* nomin */
console.log.apply(console,a)}:function(){},T.SEMVER_SPEC_VERSION="2.0.0";var U=256,V=Number.MAX_SAFE_INTEGER||9007199254740991,W=T.re=[],X=T.src=[],Y=0,Z=Y++;X[Z]="0|[1-9]\\d*";var $=Y++;X[$]="[0-9]+";
// ## Non-numeric Identifier
// Zero or more digits, followed by a letter or hyphen, and then zero or
// more letters, digits, or hyphens.
var _=Y++;X[_]="\\d*[a-zA-Z-][a-zA-Z0-9-]*";
// ## Main Version
// Three dot-separated numeric identifiers.
var aa=Y++;X[aa]="("+X[Z]+")\\.("+X[Z]+")\\.("+X[Z]+")";var ba=Y++;X[ba]="("+X[$]+")\\.("+X[$]+")\\.("+X[$]+")";
// ## Pre-release Version Identifier
// A numeric identifier, or a non-numeric identifier.
var ca=Y++;X[ca]="(?:"+X[Z]+"|"+X[_]+")";var da=Y++;X[da]="(?:"+X[$]+"|"+X[_]+")";
// ## Pre-release Version
// Hyphen, followed by one or more dot-separated pre-release version
// identifiers.
var ea=Y++;X[ea]="(?:-("+X[ca]+"(?:\\."+X[ca]+")*))";var fa=Y++;X[fa]="(?:-?("+X[da]+"(?:\\."+X[da]+")*))";
// ## Build Metadata Identifier
// Any combination of digits, letters, or hyphens.
var ga=Y++;X[ga]="[0-9A-Za-z-]+";
// ## Build Metadata
// Plus sign, followed by one or more period-separated build metadata
// identifiers.
var ha=Y++;X[ha]="(?:\\+("+X[ga]+"(?:\\."+X[ga]+")*))";
// ## Full Version String
// A main version, followed optionally by a pre-release version and
// build metadata.
// Note that the only major, minor, patch, and pre-release sections of
// the version string are capturing groups.  The build metadata is not a
// capturing group, because it should not ever be used in version
// comparison.
var ia=Y++,ja="v?"+X[aa]+X[ea]+"?"+X[ha]+"?";X[ia]="^"+ja+"$";
// like full, but allows v1.2.3 and =1.2.3, which people do sometimes.
// also, 1.0.0alpha1 (prerelease without the hyphen) which is pretty
// common in the npm registry.
var ka="[v=\\s]*"+X[ba]+X[fa]+"?"+X[ha]+"?",la=Y++;X[la]="^"+ka+"$";var ma=Y++;X[ma]="((?:<|>)?=?)";
// Something like "2.*" or "1.2.x".
// Note that "x.x" is a valid xRange identifer, meaning "any version"
// Only the first item is strictly required.
var na=Y++;X[na]=X[$]+"|x|X|\\*";var oa=Y++;X[oa]=X[Z]+"|x|X|\\*";var pa=Y++;X[pa]="[v=\\s]*("+X[oa]+")(?:\\.("+X[oa]+")(?:\\.("+X[oa]+")(?:"+X[ea]+")?"+X[ha]+"?)?)?";var qa=Y++;X[qa]="[v=\\s]*("+X[na]+")(?:\\.("+X[na]+")(?:\\.("+X[na]+")(?:"+X[fa]+")?"+X[ha]+"?)?)?";var ra=Y++;X[ra]="^"+X[ma]+"\\s*"+X[pa]+"$";var sa=Y++;X[sa]="^"+X[ma]+"\\s*"+X[qa]+"$";
// Tilde ranges.
// Meaning is "reasonably at or greater than"
var ta=Y++;X[ta]="(?:~>?)";var ua=Y++;X[ua]="(\\s*)"+X[ta]+"\\s+",W[ua]=new RegExp(X[ua],"g");var va="$1~",wa=Y++;X[wa]="^"+X[ta]+X[pa]+"$";var xa=Y++;X[xa]="^"+X[ta]+X[qa]+"$";
// Caret ranges.
// Meaning is "at least and backwards compatible with"
var ya=Y++;X[ya]="(?:\\^)";var za=Y++;X[za]="(\\s*)"+X[ya]+"\\s+",W[za]=new RegExp(X[za],"g");var Aa="$1^",Ba=Y++;X[Ba]="^"+X[ya]+X[pa]+"$";var Ca=Y++;X[Ca]="^"+X[ya]+X[qa]+"$";
// A simple gt/lt/eq thing, or just "" to indicate "any version"
var Da=Y++;X[Da]="^"+X[ma]+"\\s*("+ka+")$|^$";var Ea=Y++;X[Ea]="^"+X[ma]+"\\s*("+ja+")$|^$";
// An expression to strip any whitespace between the gtlt and the thing
// it modifies, so that `> 1.2.3` ==> `>1.2.3`
var Fa=Y++;X[Fa]="(\\s*)"+X[ma]+"\\s*("+ka+"|"+X[pa]+")",
// this one has to use the /g flag
W[Fa]=new RegExp(X[Fa],"g");var Ga="$1$2$3",Ha=Y++;X[Ha]="^\\s*("+X[pa]+")\\s+-\\s+("+X[pa]+")\\s*$";var Ia=Y++;X[Ia]="^\\s*("+X[qa]+")\\s+-\\s+("+X[qa]+")\\s*$";
// Star ranges basically just allow anything at all.
var Ja=Y++;X[Ja]="(<|>)?=?\\s*\\*";
// Compile to actual regexp objects.
// All are flag-free, unless they were created above with a flag.
for(var Ka=0;Y>Ka;Ka++)R(Ka,X[Ka]),W[Ka]||(W[Ka]=new RegExp(X[Ka]));T.parse=a,T.valid=b,T.clean=c,
// ***** MODIFIED LINE BELOW *****
window.semver=T.SemVer=d,d.prototype.format=function(){return this.version=this.major+"."+this.minor+"."+this.patch,this.prerelease.length&&(this.version+="-"+this.prerelease.join(".")),this.version},d.prototype.inspect=function(){return'<SemVer "'+this+'">'},d.prototype.toString=function(){return this.version},d.prototype.compare=function(a){return R("SemVer.compare",this.version,this.loose,a),a instanceof d||(a=new d(a,this.loose)),this.compareMain(a)||this.comparePre(a)},d.prototype.compareMain=function(a){return a instanceof d||(a=new d(a,this.loose)),g(this.major,a.major)||g(this.minor,a.minor)||g(this.patch,a.patch)},d.prototype.comparePre=function(a){
// NOT having a prerelease is > having one
if(a instanceof d||(a=new d(a,this.loose)),this.prerelease.length&&!a.prerelease.length)return-1;if(!this.prerelease.length&&a.prerelease.length)return 1;if(!this.prerelease.length&&!a.prerelease.length)return 0;var b=0;do{var c=this.prerelease[b],e=a.prerelease[b];if(R("prerelease compare",b,c,e),void 0===c&&void 0===e)return 0;if(void 0===e)return 1;if(void 0===c)return-1;if(c!==e)return g(c,e)}while(++b)},
// preminor will bump the version up to the next minor release, and immediately
// down to pre-release. premajor and prepatch work the same way.
d.prototype.inc=function(a,b){switch(a){case"premajor":this.prerelease.length=0,this.patch=0,this.minor=0,this.major++,this.inc("pre",b);break;case"preminor":this.prerelease.length=0,this.patch=0,this.minor++,this.inc("pre",b);break;case"prepatch":
// If this is already a prerelease, it will bump to the next version
// drop any prereleases that might already exist, since they are not
// relevant at this point.
this.prerelease.length=0,this.inc("patch",b),this.inc("pre",b);break;
// If the input is a non-prerelease version, this acts the same as
// prepatch.
case"prerelease":0===this.prerelease.length&&this.inc("patch",b),this.inc("pre",b);break;case"major":
// If this is a pre-major version, bump up to the same major version.
// Otherwise increment major.
// 1.0.0-5 bumps to 1.0.0
// 1.1.0 bumps to 2.0.0
(0!==this.minor||0!==this.patch||0===this.prerelease.length)&&this.major++,this.minor=0,this.patch=0,this.prerelease=[];break;case"minor":
// If this is a pre-minor version, bump up to the same minor version.
// Otherwise increment minor.
// 1.2.0-5 bumps to 1.2.0
// 1.2.1 bumps to 1.3.0
(0!==this.patch||0===this.prerelease.length)&&this.minor++,this.patch=0,this.prerelease=[];break;case"patch":
// If this is not a pre-release version, it will increment the patch.
// If it is a pre-release it will bump up to the same patch version.
// 1.2.0-5 patches to 1.2.0
// 1.2.0 patches to 1.2.1
0===this.prerelease.length&&this.patch++,this.prerelease=[];break;
// This probably shouldn't be used publicly.
// 1.0.0 "pre" would become 1.0.0-0 which is the wrong direction.
case"pre":if(0===this.prerelease.length)this.prerelease=[0];else{for(var c=this.prerelease.length;--c>=0;)"number"==typeof this.prerelease[c]&&(this.prerelease[c]++,c=-2);-1===c&&// didn't increment anything
this.prerelease.push(0)}b&&(
// 1.2.0-beta.1 bumps to 1.2.0-beta.2,
// 1.2.0-beta.fooblz or 1.2.0-beta bumps to 1.2.0-beta.0
this.prerelease[0]===b?isNaN(this.prerelease[1])&&(this.prerelease=[b,0]):this.prerelease=[b,0]);break;default:throw new Error("invalid increment argument: "+a)}return this.format(),this},T.inc=e,T.diff=f,T.compareIdentifiers=g;var La=/^[0-9]+$/;T.rcompareIdentifiers=h,T.major=i,T.minor=j,T.patch=k,T.compare=l,T.compareLoose=m,T.rcompare=n,T.sort=o,T.rsort=p,T.gt=q,T.lt=r,T.eq=s,T.neq=t,T.gte=u,T.lte=v,T.cmp=w,T.Comparator=x;var Ma={};x.prototype.parse=function(a){var b=this.loose?W[Da]:W[Ea],c=a.match(b);if(!c)throw new TypeError("Invalid comparator: "+a);this.operator=c[1],"="===this.operator&&(this.operator=""),
// if it literally is just '>' or '' then allow anything.
c[2]?this.semver=new d(c[2],this.loose):this.semver=Ma},x.prototype.inspect=function(){return'<SemVer Comparator "'+this+'">'},x.prototype.toString=function(){return this.value},x.prototype.test=function(a){return R("Comparator.test",a,this.loose),this.semver===Ma?!0:("string"==typeof a&&(a=new d(a,this.loose)),w(a,this.operator,this.semver,this.loose))},T.Range=y,y.prototype.inspect=function(){return'<SemVer Range "'+this.range+'">'},y.prototype.format=function(){return this.range=this.set.map(function(a){return a.join(" ").trim()}).join("||").trim(),this.range},y.prototype.toString=function(){return this.range},y.prototype.parseRange=function(a){var b=this.loose;a=a.trim(),R("range",a,b);
// `1.2.3 - 1.2.4` => `>=1.2.3 <=1.2.4`
var c=b?W[Ia]:W[Ha];a=a.replace(c,J),R("hyphen replace",a),a=a.replace(W[Fa],Ga),R("comparator trim",a,W[Fa]),a=a.replace(W[ua],va),a=a.replace(W[za],Aa),a=a.split(/\s+/).join(" ");
// At this point, the range is completely trimmed and
// ready to be split into comparators.
var d=b?W[Da]:W[Ea],e=a.split(" ").map(function(a){return A(a,b)}).join(" ").split(/\s+/);
// in loose mode, throw out any that are not valid comparators
return this.loose&&(e=e.filter(function(a){return!!a.match(d)})),e=e.map(function(a){return new x(a,b)})},
// Mostly just for testing and legacy API reasons
T.toComparators=z,
// if ANY of the sets match ALL of its comparators, then pass
y.prototype.test=function(a){if(!a)return!1;"string"==typeof a&&(a=new d(a,this.loose));for(var b=0;b<this.set.length;b++)if(K(this.set[b],a))return!0;return!1},T.satisfies=L,T.maxSatisfying=M,T.validRange=N,
// Determine if version is less than all the versions possible in the range
T.ltr=O,
// Determine if version is greater than all the versions possible in the range.
T.gtr=P,T.outside=Q,
// Use the define() function if we're in AMD land
"function"==typeof define&&define.amd&&define(T)}();